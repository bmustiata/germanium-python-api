Germanium Selectors and Locators
================================

`Selector` objects are similar to `String` values, that describe how an element
can be found in the current page, while `Locator` objects are the implementation
of actual aglorithms that find them. A parallel can be made between the string
`"div.custom-text"`, and the `webdriver.find_element_by_css()` function. Selectors
specify what you want to find in the page, and locators make sure you find them.
It's the combination of them, `webdriver.find_element_by_css("div.custom-text")` that
will return the actual DOM Element to interact with.

Selectors are in the end text strings. Locators evaluate them finding elements in
the browser.

In all the API calls, where `selector` is specified, the selector is actually one of:

1. a string selector,
2. an object that inerits from `AbstractSelector` (such as `Text`, `Element`, `Image`, etc.),
3. a WebDriver WebElement,
4. a locator,
5. a list of any of the above.

Usually point 1 and 2, would cover 99% of all your test cases.

Locators Overview
-----------------

Locators are algorithms that are are able to find elements against the current browser.
They are registered on the Germanium instance, and by default, Germanium comes with
three locators registered: `"xpath"`, `"css"` and `"js"`. These are implemented in
`XPathLocator`, `CssLocator` and `JsLocator` respectively, from the `germanium.locators`
package.

These locators all extend a base class named `DeferredLocator`. This class holds the
reference to the `Germanium` object, and offers utility methods to actually fetch
the elements. Note, that the locators don't immediately find the elements, but
explicit calls to either `element()`, `element_list()` or the locator itself `()`, since
it is a callable, and will return the `element_list()` when called:

[source,python]
-----------------------------------------------------------------------------
from germanium.util import wait

label_divs_locator = germanium.S('.label')  # <1>
wait(label_divs_locator)                    # <2>
-----------------------------------------------------------------------------
<1> This will return a `CssLocator`.
<2> Since the locator is a callable, we can wait on it


[plantuml, germanium-locators-overview, svg]
------------------------------------------------------------------------------
class DeferredLocator {
    +__call__() : list<WebElement>
    +element(only_visible: boolean) : WebElement
    +element_list(only_visible: boolean) : list<WebElement>
    {abstract} #_find_element(only_visible: boolean) : WebElement
    {abstract} #_find_element_list(only_visible: boolean) : list<WebElement>
}

class CssLocator
class XPathLocator
class JsLocator

DeferredLocator <|-- CssLocator
DeferredLocator <|-- XPathLocator
DeferredLocator <|-- JsLocator
------------------------------------------------------------------------------

A locator is always constructed with two things: the `Germanium` instance it will use
to attept at finding the elements, and a `string` expression that will be used
for finding. Note that you should never manually instantiate the locator, but
you should use the super locator (the `S` function). This function will pass both the
germanium instance, and the selector itself.

The locators can be manually specified from selectors by specifying the strategy when
using the super locator:

[source,python]
-----------------------------------------------------------------------------
germanium.S('#testDiv', strategy='css')
-----------------------------------------------------------------------------

or by prefixing the string itself with the strategy name:

[source,python]
-----------------------------------------------------------------------------
germanium.S('css:#testDiv')
-----------------------------------------------------------------------------

String Selectors
----------------

A string selector is a selector that can specify what locators to be used. Implicitly,
the selector is either an XPath if it starts with `"//"`, either a CSS
selector, if there is no identifier.

A string selector can also specify its locator strategy, by prefixing the selector
with the locator strategy name. Currently registered into Germanium are:

*css*

[source,python]
-----------------------------------------------------------------------------
selector = "css:div#customID"

# or without the css prefix, since the string it's
# not starting with //
selector = "div#customID"
-----------------------------------------------------------------------------

*xpath*

[source,python]
-----------------------------------------------------------------------------
selector = "xpath://div[@id='customID']"

# or without the xpath prefix, since the string it's
# starting with //
selector = "//div[@id='customID']"
-----------------------------------------------------------------------------

*js*

[source,python]
-----------------------------------------------------------------------------
selector = "js:return [ document.getElementById('customID') ];"
-----------------------------------------------------------------------------


Selectors Overview
------------------

All `Selector` objects in Germanium inherit from `germanium.selector.AbstractSelector`, which
define a single required method:

[source,python]
-----------------------------------------------------------------------------
class AbstractSelector(object):
    """
    Just a marker interface.
    """
    def __init__(self):
        pass

    def get_selectors(self):
        raise Exception("Abstract class, not implemented.") # <1>

    # ... positional, and parent-child filtering methods
-----------------------------------------------------------------------------
<1> Note that the method name is `get_selectors`. This method must return a list of string
selectors, that can even have different locator strategies.

All the Selector objects return a list of strings, that define how the element, or the multiple
elements will be found by the given locator.

Positional Filtering
--------------------

Germanium provides the following methods to enable positional filtering: `left_of(selector)`,
`right_of(selector)`, `below(selector)`, `above(selector)`, that is excluding elements that
are in weird positions. These filters can be used to filter otherwise false positive matches
when selecting.

Multiple filters can be chained for the same selector, for example someone can:

[source,python]
-----------------------------------------------------------------------------
click(Link("edit")
        .below(Text("User Edit Panel"))
        .right_of(Text("User 11")))
-----------------------------------------------------------------------------

This will find a link that contains the label `edit`, that is positioned below
the text `User Edit Panel` and is to the right of the text `User 11`.

=== selector.left_of(other_selector)

*Description*

Make a selector that will return only the items that are left of all the elements
returned by the other_selector.

*Signature*

[source,python]
-----------------------------------------------------------------------------
def left_of(self, other_selector)
-----------------------------------------------------------------------------

*Sample*

[source,python]
-----------------------------------------------------------------------------
click(Input().left_of(Text("User")))
-----------------------------------------------------------------------------

=== selector.right_of(other_selector)

Make a selector that will return only the items that are right of all the elements
returned by the other_selector.

[source,python]
-----------------------------------------------------------------------------
click(Link("edit").right_of(Text("User 11")))
-----------------------------------------------------------------------------

=== selector.above(other_selector)

Make a selector that will return only the items that are above all the elements
returned by the other_selector.

[source,python]
-----------------------------------------------------------------------------
click(Link("logout").above("div.toolbar"))
-----------------------------------------------------------------------------

=== selector.below(other_selector)

Make a selector that will return only the items that are below all the elements
returned by the other_selector.

[source,python]
-----------------------------------------------------------------------------
click(Button("edit").below(Text("entry 5")))
-----------------------------------------------------------------------------

Writing Custom Selectors
------------------------

You can write a new selector by extending the AbstractSelector class and implementing
the `get_selectors` method, that returns an array of selectors to be searched in the
document.

[plantuml, germanium-abstract-selector, svg]
------------------------------------------------------------------------------
class AbstractSelector {
    -- method to implement --
    {abstract} +List<string> get_selectors()
    -- positional filtering --
    +PositionalFilterSelector left_of(selector)
    +PositionalFilterSelector right_of(selector)
    +PositionalFilterSelector below(selector)
    +PositionalFilterSelector above(selector)
    -- parent/child filtering --
    +XPathInsideFilterSelector inside(selector)
    +XPathInsideFilterSelector containing(selector)
}

class PositionalFilterSelector {
    +PositionalFilterSelector left_of(selector)
    +PositionalFilterSelector right_of(selector)
    +PositionalFilterSelector below(selector)
    +PositionalFilterSelector above(selector)
}

class XPathInsideFilterSelector {
    +XPathInsideFilterSelector inside(selector)
    +XPathInsideFilterSelector containing(selector)
}

AbstractSelector <|-- PositionalFilterSelector
AbstractSelector <|-- XPathInsideFilterSelector
------------------------------------------------------------------------------

[WARN]
Please take note that in order to use `inside` and `containing` filtering,
the selector must return all its expressions as XPath selectors.

